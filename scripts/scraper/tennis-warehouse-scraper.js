#!/usr/bin/env node

/**
 * Scraper respectueux pour TennisWarehouse.com
 * Respecte les robots.txt et impl√©mente des d√©lais appropri√©s
 */

const axios = require('axios');
const cheerio = require('cheerio');
const fs = require('fs').promises;
const path = require('path');

class TennisWarehouseScraper {
  constructor() {
    this.baseUrl = 'https://www.tennis-warehouse.com';
    this.delay = 2000; // 2 secondes entre les requ√™tes
    this.maxRetries = 3;
    this.outputDir = path.join(__dirname, '../../data/scraped');
    this.headers = {
      'User-Agent': 'Tennis String Advisor - Research Tool (respectful scraping)',
      'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
      'Accept-Language': 'en-US,en;q=0.5',
      'Accept-Encoding': 'gzip, deflate',
      'Connection': 'keep-alive'
    };
  }

  async init() {
    try {
      await fs.mkdir(this.outputDir, { recursive: true });
      console.log('üöÄ Initialisation du scraper TennisWarehouse');
      
      // V√©rifier robots.txt
      await this.checkRobotsTxt();
      
    } catch (error) {
      console.error('Erreur d\'initialisation:', error);
      throw error;
    }
  }

  async checkRobotsTxt() {
    try {
      console.log('ü§ñ V√©rification du robots.txt...');
      const response = await axios.get(`${this.baseUrl}/robots.txt`, {
        headers: this.headers,
        timeout: 10000
      });
      
      console.log('üìã Contenu du robots.txt:');
      console.log(response.data);
      
      // Analyser les restrictions
      const robotsContent = response.data.toLowerCase();
      if (robotsContent.includes('disallow: /')) {
        console.warn('‚ö†Ô∏è  ATTENTION: Le robots.txt indique des restrictions');
        console.warn('   Assurez-vous de respecter les conditions d\'utilisation');
      }
      
    } catch (error) {
      console.warn('‚ö†Ô∏è  Impossible de r√©cup√©rer robots.txt:', error.message);
    }
  }

  async delay(ms = this.delay) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async makeRequest(url, retries = 0) {
    try {
      console.log(`üì° Requ√™te: ${url}`);
      
      const response = await axios.get(url, {
        headers: this.headers,
        timeout: 15000,
        maxRedirects: 5
      });

      // Respecter le d√©lai entre les requ√™tes
      await this.delay();
      
      return response.data;
      
    } catch (error) {
      if (retries < this.maxRetries) {
        console.warn(`‚ö†Ô∏è  √âchec de la requ√™te, nouvelle tentative (${retries + 1}/${this.maxRetries})`);
        await this.delay(this.delay * (retries + 1)); // D√©lai croissant
        return this.makeRequest(url, retries + 1);
      }
      
      console.error(`‚ùå √âchec d√©finitif pour ${url}:`, error.message);
      return null;
    }
  }

  async scrapeStringCategories() {
    console.log('üéæ Scraping des cat√©gories de cordages...');
    
    const categoriesUrl = `${this.baseUrl}/strings/`;
    const html = await this.makeRequest(categoriesUrl);
    
    if (!html) return [];

    const $ = cheerio.load(html);
    const categories = [];

    // Adapter les s√©lecteurs selon la structure r√©elle du site
    $('.category-link, .string-category, [data-category]').each((i, element) => {
      const $el = $(element);
      const name = $el.text().trim();
      const url = $el.attr('href');
      
      if (name && url) {
        categories.push({
          name,
          url: url.startsWith('http') ? url : `${this.baseUrl}${url}`,
          type: 'string'
        });
      }
    });

    console.log(`‚úÖ ${categories.length} cat√©gories de cordages trouv√©es`);
    return categories;
  }

  async scrapeRacquetCategories() {
    console.log('üéæ Scraping des cat√©gories de raquettes...');
    
    const categoriesUrl = `${this.baseUrl}/racquets/`;
    const html = await this.makeRequest(categoriesUrl);
    
    if (!html) return [];

    const $ = cheerio.load(html);
    const categories = [];

    $('.category-link, .racquet-category, [data-category]').each((i, element) => {
      const $el = $(element);
      const name = $el.text().trim();
      const url = $el.attr('href');
      
      if (name && url) {
        categories.push({
          name,
          url: url.startsWith('http') ? url : `${this.baseUrl}${url}`,
          type: 'racquet'
        });
      }
    });

    console.log(`‚úÖ ${categories.length} cat√©gories de raquettes trouv√©es`);
    return categories;
  }

  async scrapeProductsFromCategory(category, limit = 50) {
    console.log(`üîç Scraping des produits de la cat√©gorie: ${category.name}`);
    
    const html = await this.makeRequest(category.url);
    if (!html) return [];

    const $ = cheerio.load(html);
    const products = [];

    // S√©lecteurs g√©n√©riques pour les produits (√† adapter selon le site r√©el)
    $('.product-item, .product-card, [data-product]').each((i, element) => {
      if (i >= limit) return false; // Limiter le nombre de produits

      const $el = $(element);
      const $link = $el.find('a').first();
      const $img = $el.find('img').first();
      const $price = $el.find('.price, .product-price, [data-price]').first();

      const product = {
        category: category.name,
        type: category.type,
        name: $link.attr('title') || $link.text().trim(),
        url: $link.attr('href'),
        image: $img.attr('src') || $img.attr('data-src'),
        price: $price.text().trim(),
        scrapedAt: new Date().toISOString()
      };

      // Nettoyer les URLs relatives
      if (product.url && !product.url.startsWith('http')) {
        product.url = `${this.baseUrl}${product.url}`;
      }
      if (product.image && !product.image.startsWith('http')) {
        product.image = `${this.baseUrl}${product.image}`;
      }

      if (product.name && product.url) {
        products.push(product);
      }
    });

    console.log(`‚úÖ ${products.length} produits trouv√©s dans ${category.name}`);
    return products;
  }

  async scrapeProductDetails(product) {
    console.log(`üìã D√©tails du produit: ${product.name}`);
    
    const html = await this.makeRequest(product.url);
    if (!html) return product;

    const $ = cheerio.load(html);

    // Extraire les sp√©cifications d√©taill√©es
    const specifications = {};
    
    // S√©lecteurs pour les sp√©cifications (√† adapter)
    $('.spec-table tr, .specifications li, .product-details li').each((i, element) => {
      const $el = $(element);
      const label = $el.find('.spec-label, .label, td:first-child').text().trim();
      const value = $el.find('.spec-value, .value, td:last-child').text().trim();
      
      if (label && value) {
        specifications[label.toLowerCase().replace(/[^a-z0-9]/g, '_')] = value;
      }
    });

    // Description
    const description = $('.product-description, .description').text().trim();

    // Prix d√©taill√©
    const priceDetails = {
      current: $('.current-price, .price-current').text().trim(),
      original: $('.original-price, .price-original').text().trim(),
      discount: $('.discount, .sale-badge').text().trim()
    };

    // Images additionnelles
    const images = [];
    $('.product-gallery img, .additional-images img').each((i, element) => {
      const src = $(element).attr('src') || $(element).attr('data-src');
      if (src) {
        images.push(src.startsWith('http') ? src : `${this.baseUrl}${src}`);
      }
    });

    return {
      ...product,
      specifications,
      description,
      priceDetails,
      images,
      detailsScrapedAt: new Date().toISOString()
    };
  }

  async scrapeAll() {
    try {
      await this.init();
      
      console.log('üöÄ D√©but du scraping complet...');
      
      // Scraper les cat√©gories
      const stringCategories = await this.scrapeStringCategories();
      const racquetCategories = await this.scrapeRacquetCategories();
      
      const allCategories = [...stringCategories, ...racquetCategories];
      
      // Sauvegarder les cat√©gories
      await this.saveData('categories.json', allCategories);
      
      // Scraper les produits par cat√©gorie
      const allProducts = [];
      
      for (const category of allCategories.slice(0, 5)) { // Limiter pour les tests
        console.log(`\nüìÇ Traitement de la cat√©gorie: ${category.name}`);
        
        const products = await this.scrapeProductsFromCategory(category, 20);
        
        // Scraper les d√©tails pour quelques produits
        for (const product of products.slice(0, 5)) {
          const detailedProduct = await this.scrapeProductDetails(product);
          allProducts.push(detailedProduct);
        }
        
        // Sauvegarder p√©riodiquement
        await this.saveData(`products_${category.type}_${Date.now()}.json`, allProducts);
      }
      
      // Sauvegarder le r√©sultat final
      await this.saveData('all_products.json', allProducts);
      
      console.log('\n‚úÖ Scraping termin√©!');
      console.log(`üìä Total: ${allProducts.length} produits r√©cup√©r√©s`);
      console.log(`üìÅ Donn√©es sauvegard√©es dans: ${this.outputDir}`);
      
      return {
        categories: allCategories,
        products: allProducts,
        summary: {
          totalCategories: allCategories.length,
          totalProducts: allProducts.length,
          stringCategories: stringCategories.length,
          racquetCategories: racquetCategories.length,
          scrapedAt: new Date().toISOString()
        }
      };
      
    } catch (error) {
      console.error('‚ùå Erreur lors du scraping:', error);
      throw error;
    }
  }

  async saveData(filename, data) {
    try {
      const filepath = path.join(this.outputDir, filename);
      await fs.writeFile(filepath, JSON.stringify(data, null, 2));
      console.log(`üíæ Donn√©es sauvegard√©es: ${filename}`);
    } catch (error) {
      console.error('Erreur de sauvegarde:', error);
    }
  }

  // M√©thode pour scraping incr√©mental
  async updateProducts(existingProducts = []) {
    console.log('üîÑ Mise √† jour incr√©mentale des produits...');
    
    // Logique de mise √† jour bas√©e sur les timestamps
    const cutoffDate = new Date();
    cutoffDate.setHours(cutoffDate.getHours() - 24); // Derni√®res 24h
    
    const productsToUpdate = existingProducts.filter(p => 
      !p.detailsScrapedAt || new Date(p.detailsScrapedAt) < cutoffDate
    );
    
    console.log(`üîÑ ${productsToUpdate.length} produits √† mettre √† jour`);
    
    for (const product of productsToUpdate) {
      const updated = await this.scrapeProductDetails(product);
      // Logique de mise √† jour...
    }
  }
}

// Ex√©cution si appel√© directement
if (require.main === module) {
  const scraper = new TennisWarehouseScraper();
  
  // Gestion des signaux pour arr√™t propre
  process.on('SIGINT', () => {
    console.log('\n‚è∏Ô∏è  Arr√™t du scraping...');
    process.exit(0);
  });
  
  scraper.scrapeAll()
    .then(result => {
      console.log('\nüìà R√âSUM√â:');
      console.log(`Cat√©gories: ${result.summary.totalCategories}`);
      console.log(`Produits: ${result.summary.totalProducts}`);
    })
    .catch(error => {
      console.error('Erreur fatale:', error);
      process.exit(1);
    });
}

module.exports = TennisWarehouseScraper;